%{
#include <iostream>
#include <string>
#include "naturaldeduction.hpp"

#define YYDEBUG 1 // for debugging

using namespace std;

// Error handling
void yyerror(Formula & formula, const string message) {
  cerr << message << endl;
  exit(EXIT_FAILURE);
}

// Lexical analyzer
extern int yylex();
  
%}

// Union for representing attribute type for tokens and expressions
%union {
  string * s;
  Formula * f = new Formula();
}

// Defining tokens
%token <s> atom_token
%token not_token
%token true_token
%token false_token

// Expression attribute
%type <f> E

// Operators precedence and associativity
%left imp_token iff_token
%left or_token and_token
%left NOT

%parse-param { Formula & formula }

%%
Program: Formula '\n' Program
| 
;

Formula: E                { formula = *$1; return 0; }
;

E : E and_token E         { $$ = new Formula(make_shared<And>(*$1, *$3)); } 
| E or_token E            { $$ = new Formula(make_shared<Or>(*$1, *$3)); }
| E imp_token E           { $$ = new Formula(make_shared<Imp>(*$1, *$3)); }
// converting A <=> B to (A => B) /\ (B => A)
| E iff_token E           { $$ = new Formula(make_shared<Iff>(*$1, *$3)->simplify()); }
| not_token E %prec NOT   { $$ = new Formula(make_shared<Not>(*$2)); }
| '(' E ')'               { $$ = $2; }
| atom_token              { $$ = new Formula(make_shared<Atom>(*$1)); }
| true_token              { $$ = new Formula(make_shared<True>()); }
| false_token             { $$ = new Formula(make_shared<False>()); }
;

%%

// Function for parsing formula
Formula parseFormula() {
  Formula f;
  yyparse(f);

  return f;
}

// Function for clearing input buffer
void clearInputBuffer() {
  cin.clear();
  cin.ignore();
}

int main () {
  // yydebug = 1;
  Goals goals;
  bool exit = false;
  int ruleNumber;

  string rules = "Select rule to apply (-1 to exit):\n";
  rules += "0. assumption\n";
  rules += "1. notI\n";
  rules += "2. notE\n";
  rules += "3. conjI\n";
  rules += "4. conjE1\n";
  rules += "5. conjE2\n";
  rules += "6. disjI1\n";
  rules += "7. disjI2\n";
  rules += "8. disjE\n";
  rules += "9. impI\n";
  rules += "10. impE\n";
  rules += "11. falseE\n";
  rules += "12. trueI\n";
  rules += "13. ExcludedMiddle\n";
  rules += "14. DoubleNegation\n";
  rules += "15. Contradiction\n";

  string invalidRuleNumber = "Please select a valid rule number (between 0 and 15), or -1 to exit";

  cout << "Enter formula:" << endl;
  Formula f = parseFormula();

  goals.push_back(make_pair(vector<Formula>(), f));

  while(goals.size() > 0 && !exit) {
    cout << goals << endl;
    cout << rules << endl;
    cin >> ruleNumber;
    if(cin.fail()) {
      cout << invalidRuleNumber << endl;
      clearInputBuffer();
    }
    else {
      while(ruleNumber < -1 || ruleNumber > 15) {
        cout << invalidRuleNumber << endl;
        cout << goals << endl;
        cout << rules << endl;
        cin >> ruleNumber;
        if(cin.fail()) {
          cout << invalidRuleNumber << endl;
          clearInputBuffer();
        };
      };

      vector<Goal> subgoals;

      switch(ruleNumber) {
        case -1:
          exit = true;
          break;
        case 0:
          if(applyAssumption(goals[0]))
            goals.pop_front();
          break;
        case 1:
          applyNotI(goals[0]);
          break;
        case 2:
          applyNotE(goals[0]);
          break;
        case 3:
          subgoals.clear();
          applyConjI(goals[0], subgoals);
          goals.pop_front();
          for(int j = subgoals.size() - 1; j >= 0; j--)
            goals.push_front(subgoals[j]);
          break;
        case 4:
          applyConjE1(goals[0]);
          break;
        case 5:
          applyConjE2(goals[0]);
          break;
        case 6:
          applyDisjI1(goals[0]);
          break;
        case 7:
          applyDisjI2(goals[0]);
          break;
        case 8:
          subgoals.clear();
          applyDisjE(goals[0], subgoals);
          goals.pop_front();
          for(int j = subgoals.size() - 1; j >= 0; j--)
            goals.push_front(subgoals[j]);
          break;
        case 9:
          applyImpI(goals[0]);
          break;
        case 10:
          applyImpE(goals[0]);
          break;
        case 11:
          applyFalseE(goals[0]);
          break;
        case 12:
          if(applyTrueI(goals[0]))
            goals.pop_front();
          break;
        case 13:
          if(applyExcludedMiddle(goals[0]))
            goals.pop_front();
          break;
        case 14:
          applyDoubleNegation(goals[0]);
          break;
        case 15:
          applyContradiction(goals[0]);
          break;
      };
    };
  };

  if(exit)
    cout << "Exiting..." << endl;
  else
    cout << endl << "Theorem proved: " << f << endl;

  return 0;
}