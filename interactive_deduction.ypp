%{
#include <iostream>
#include <string>
// #include <cstdlib>
// #include <map>    
#include "naturaldeduction.hpp"

#define YYDEBUG 1 // for debugging

using namespace std;

// Error handling
void yyerror(Formula & formula, const string message) {
  cerr << message << endl;
  exit(EXIT_FAILURE);
}

// Lexical analyzer
extern int yylex();
  
%}

// Union for representing attribute type for tokens and expressions
%union {
  string * s;
  Formula * f = new Formula();
}

// Defining tokens
%token <s> atom_token
%token not_token
%token true_token
%token false_token

// Expression attribute
%type <f> E

// Operators priority and associativity
%left imp_token iff_token
%left or_token and_token
%left NOT

%parse-param { Formula & formula }

%%
Program: Formula '\n' Program
| 
;

Formula: E                { formula = *$1; return 0; }
;

E : E and_token E         { $$ = new Formula(make_shared<And>(*$1, *$3)); } 
| E or_token E            { $$ = new Formula(make_shared<Or>(*$1, *$3)); }
| E imp_token E           { $$ = new Formula(make_shared<Imp>(*$1, *$3)); }
// converting A <=> B to (A => B) /\ (B => A)
| E iff_token E           { $$ = new Formula(make_shared<Iff>(*$1, *$3)->simplify()); }
| not_token E %prec NOT   { $$ = new Formula(make_shared<Not>(*$2)); }
| '(' E ')'               { $$ = $2; }
| atom_token              { $$ = new Formula(make_shared<Atom>(*$1)); }
| true_token              { $$ = new Formula(make_shared<True>()); }
| false_token             { $$ = new Formula(make_shared<False>()); }
;

%%

// Function for parsing formula
Formula parseFormula() {
  Formula f;
  yyparse(f);

  return f;
}

// Function for clearing input buffer
void clearInputBuffer() {
  cin.clear();
  cin.ignore();
}

// Apply rule helper function
bool applyRule(vector<vector<Formula>> & assumptionsVec, vector<Formula> & goals, int inputNum, Formula & A, Formula B = make_shared<True>()) {
  bool returnValue;
  Formula result, goal = goals[goals.size() - 1];
  vector<Formula> resultVec, assumptions;

  goals.pop_back();

  switch (inputNum) {
  case 0: // assumption
    assumptions = assumptionsVec[assumptionsVec.size() - 1];
    assumptionsVec.pop_back();
    returnValue = applyAssumption(assumptions, goal);
    if(!returnValue) {
      goals.push_back(goal);
      assumptionsVec.push_back(assumptions);
    };
    return returnValue;

  case 1: // notI
    assumptions = assumptionsVec[assumptionsVec.size() - 1];
    result = applyNotI(assumptions, goal);
    goals.push_back(result);
    return !result.get()->equalTo(goal);

  case 2: // notE
    assumptions = assumptionsVec[assumptionsVec.size() - 1];
    resultVec = applyNotE(A, goal);
    if(resultVec[0]->equalTo(goal)) {
      goals.push_back(goal);
      return false;
    }
    else {
      assumptionsVec.push_back(assumptions);
      goals.push_back(resultVec[0]);
      goals.push_back(resultVec[1]);
      return true;
    };

  case 3: // conjI
    assumptions = assumptionsVec[assumptionsVec.size() - 1];
    assumptionsVec.pop_back();
    resultVec = applyConjI(goal);
    if(resultVec[0]->equalTo(goal)) {
      goals.push_back(goal);
      assumptionsVec.push_back(assumptions);
      return false;
    }
    else {
      for(unsigned i = 0; i < resultVec.size(); i++) {
        goals.push_back(resultVec[i]);
        assumptionsVec.push_back(assumptions);
      };
      return true;
    };

  case 4: // conjE1
    result = applyConjE1(goal, A);
    if(result->equalTo(goal)) {
      goals.push_back(goal);
      return false;
    }
    else {
      goals.push_back(result);
      return true;
    };

  case 5: // conjE2
    result = applyConjE2(goal, A);
    if(result->equalTo(goal)) {
      goals.push_back(goal);
      return false;
    }
    else {
      goals.push_back(result);
      return true;
    };

  case 6: // disjI1
    result = applyDisjI1(goal);
    if(result->equalTo(goal)) {
      goals.push_back(goal);
      return false;
    }
    else {
      goals.push_back(result);
      return true;
    };

  case 7: // disjI2
    result = applyDisjI2(goal);
    if(result->equalTo(goal)) {
      goals.push_back(goal);
      return false;
    }
    else {
      goals.push_back(result);
      return true;
    };

  case 8: // disjE
    assumptions = assumptionsVec[assumptionsVec.size() - 1];
    assumptionsVec.pop_back();
    resultVec = applyDisjE(goal, A, B);
    goals.push_back(resultVec[0]);
    assumptionsVec.push_back(assumptions);
    goals.push_back(resultVec[1]);
    assumptions.push_back(A);
    assumptionsVec.push_back(assumptions);
    goals.push_back(resultVec[1]);
    assumptions.pop_back();
    assumptions.push_back(B);
    assumptionsVec.push_back(assumptions);
    return true;

  case 9: // impI
    assumptions = assumptionsVec[assumptionsVec.size() - 1];
    result = applyImpI(assumptions, goal);
    if(result->equalTo(goal)) {
      goals.push_back(goal);
      return false;
    }
    else {
      goals.push_back(result);
      return true;
    };

  case 10: // impE
    assumptions = assumptionsVec[assumptionsVec.size() - 1];
    assumptionsVec.pop_back();
    resultVec = applyImpE(A, goal);
    for(unsigned i = 0; i < resultVec.size(); i++) {
      goals.push_back(resultVec[i]);
      assumptionsVec.push_back(assumptions);
    };
    return true;

  case 11: // falseE
    result = applyFalseE(goal);
    if(result->equalTo(goal)) {
      goals.push_back(goal);
      return false;
    }
    else {
      goals.push_back(result);
      return true;
    };

  case 12: // trueI
    assumptionsVec.pop_back();
    return applyTrueI(goal);

  case 13: // ExcludedMiddle
    returnValue = applyExcludedMiddle(goal);
    if(returnValue)
      assumptionsVec.pop_back();
    else
      goals.push_back(goal);
    return returnValue;

  case 14: // DoubleNegation
    result = applyDoubleNegation(goal);
    goals.push_back(result);
    return !result->equalTo(goal);

  case 15: // Contradiction
    assumptions = assumptionsVec[assumptionsVec.size() - 1];
    result = applyContradiction(assumptions, goal);
    goals.push_back(result);
    return !result->equalTo(goal);

  default:
    cout << "Please select a number between 0 and 15 to apply a rule" << endl;
    return false;
  }
}

int main () {
  // yydebug = 1;
  string rules = "Select rule to apply (-1 to exit):\n";
  rules += "0. assumption\n";
  rules += "1. notI\n";
  rules += "2. notE\n";
  rules += "3. conjI\n";
  rules += "4. conjE1\n";
  rules += "5. conjE2\n";
  rules += "6. disjI1\n";
  rules += "7. disjI2\n";
  rules += "8. disjE\n";
  rules += "9. impI\n";
  rules += "10. impE\n";
  rules += "11. falseE\n";
  rules += "12. trueI\n";
  rules += "13. ExcludedMiddle\n";
  rules += "14. DoubleNegation\n";
  rules += "15. Contradiction\n";

  cout << "Enter formula:" << endl << endl;
  Formula f = parseFormula();

  vector<vector<Formula>> assumptionsVec = vector<vector<Formula>>();
  assumptionsVec.push_back(vector<Formula>());
  vector<Formula> goals = vector<Formula>();
  goals.push_back(f);

  bool cont = true;
  int i;

  while(goals.size() > 0 && cont) {
    cout << endl << "Goals:" << endl;
    for(int j = goals.size() - 1; j >= 0; j--) {
      cout << goals.size() - j << ". ";
      for(unsigned k = 0; k < assumptionsVec[j].size(); k++) {
        cout << assumptionsVec[j][k];
        if(k < assumptionsVec[j].size() - 1)
          cout << " , ";
      };
      cout << " |-- ";
      cout << goals[j] << endl;
    };
    cout << endl << rules << endl;
    cin >> i;
    if(cin.fail()) {
      clearInputBuffer();
    }
    else {
      while(i < -1 || i > 15) {
        cout << endl;
        cout << "Warning: invalid rule number" << endl;
        cout << "Please select a valid rule number (between 0 and 15), or -1 to exit" << endl;
        cout << endl;
        cout << rules << endl;
        cin >> i;
        if(cin.fail())
          clearInputBuffer();
      };
      if(i == -1)
        cont = false;
      // else if(i == 16) {
      //   cout << "Unesite broj formule koju zelite da dokazujete:" << endl;
      //   cin >> i;
      //   while (i<1 || i>goals.size()) {
      //     cout << "Uneli ste pogresan broj za formulu, pokusajte ponovo!" << endl;
      //     cout << "Unesite broj formule koju zelite da dokazujete : " << endl;
      //     cin >> i;
      //   }
      //   int k = goals.size();
      //   Formula pomRight = goals[k - i];
      //   vector <Formula> leftSidePom = assumptionsVec[k - i];
      //   goals.push_back(pomRight);
      //   assumptionsVec.push_back(leftSidePom);
      //   goals.erase(goals.begin() + (k - i));
      //   assumptionsVec.erase(assumptionsVec.begin() + (k - i));
      // }
      else if(i == 2 || i == 10 || i == 4 || i == 5) {
        // clearing input buffer
        clearInputBuffer();

        cout << endl << "Enter additional formula:" << endl;
        Formula g = parseFormula();
        bool result = applyRule(assumptionsVec, goals, i, g);
        if(!result)
          cout << "Rule not applied" << endl;
      }
      else if(i == 8) {
        // clearing input buffer
        clearInputBuffer();

        cout << endl << "Enter additional formula A:" << endl;
        Formula a = parseFormula();

        cout << endl << "Enter additional formula B:" << endl;
        Formula b = parseFormula();
        bool result = applyRule(assumptionsVec, goals, i, a, b);
        if(!result)
          cout << "Rule not applied" << endl;
      }
      else {
        Formula g = Formula(new True());
        bool result = applyRule(assumptionsVec, goals, i, g);
        if(!result)
          cout << "Rule not applied" << endl;
      };
    };
  };
  if(cont == false)
    cout << "Exiting..." << endl;
  else
    cout << "Formula " << f << " is a theorem" << endl;

  return 0;
}